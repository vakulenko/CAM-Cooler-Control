   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  94               	.global	__vector_default
  96               	__vector_default:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.85 (Dec. 2008)
   5:main.c        **** * Compiler : avr-gcc 4.1.2 / avr-libc 1.4.6
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *            Additional code and improvements contributed by:
  10:main.c        **** *           - Uwe Bonnes 
  11:main.c        **** *           - Bjoern Riemer
  12:main.c        **** *           - Olaf Rempel
  13:main.c        **** *
  14:main.c        **** * License  : Copyright (c) 2006-2008 M. Thomas, U. Bonnes, O. Rempel
  15:main.c        **** *            Free to use. You have to mention the copyright
  16:main.c        **** *            owners in source-code and documentation of derived
  17:main.c        **** *            work. No warranty! (Yes, you can insert the BSD
  18:main.c        **** *            license here)
  19:main.c        **** *
  20:main.c        **** * Tested with ATmega8, ATmega16, ATmega162, ATmega32, ATmega324P,
  21:main.c        **** *             ATmega644, ATmega644P, ATmega128, AT90CAN128
  22:main.c        **** *
  23:main.c        **** * - Initial versions have been based on the Butterfly bootloader-code
  24:main.c        **** *   by Atmel Corporation (Authors: BBrandal, PKastnes, ARodland, LHM)
  25:main.c        **** *
  26:main.c        **** ****************************************************************************
  27:main.c        **** *
  28:main.c        **** *  See the makefile and readme.txt for information on how to adapt 
  29:main.c        **** *  the linker-settings to the selected Boot Size (BOOTSIZE=xxxx) and 
  30:main.c        **** *  the MCU-type. Other configurations futher down in this file.
  31:main.c        **** *
  32:main.c        **** *  With BOOT_SIMPLE, minimal features and discarded int-vectors
  33:main.c        **** *  this bootloader has should fit into a a 512 word (1024, 0x400 bytes) 
  34:main.c        **** *  bootloader-section. 
  35:main.c        **** *
  36:main.c        **** ****************************************************************************/
  37:main.c        **** 
  38:main.c        **** /* Частота контроллера (кварца) */
  39:main.c        **** #ifndef F_CPU
  40:main.c        **** // #define F_CPU 7372800
  41:main.c        **** //#define F_CPU (7372800/2)
  42:main.c        **** #define F_CPU 8000000
  43:main.c        **** #endif
  44:main.c        **** 
  45:main.c        **** /* UART Скорость UART оптимально 19200 */
  46:main.c        **** //#define BAUDRATE 9600
  47:main.c        **** #define BAUDRATE 19200
  48:main.c        **** //#define BAUDRATE 115200
  49:main.c        **** 
  50:main.c        **** /* Режим двойной скорости UART (бит U2C)*/
  51:main.c        **** //#define UART_DOUBLESPEED
  52:main.c        **** 
  53:main.c        **** /* Используется второй UART на mega128 / can128 / mega162 / mega324p / mega644p */
  54:main.c        **** //#define UART_USE_SECOND
  55:main.c        **** 
  56:main.c        **** /* Тип устройства:
  57:main.c        ****    Для AVRProg выбирать BOOT 
  58:main.c        ****    Это корректное значение для bootloader.
  59:main.c        ****    avrdude может определить только part-code для ISP */
  60:main.c        **** #define DEVTYPE     DEVTYPE_BOOT
  61:main.c        **** // #define DEVTYPE     DEVTYPE_ISP
  62:main.c        **** 
  63:main.c        **** /*
  64:main.c        ****  * Выбор порта для кнопки входа в загрузчик
  65:main.c        ****  * Чтобы войти в загрузчик надо чтобы при запуске эта кнопка замыкала пин на землю
  66:main.c        ****  */
  67:main.c        ****  
  68:main.c        **** #define BLPORT		PORTD
  69:main.c        **** #define BLDDR		DDRD
  70:main.c        **** #define BLPIN		PIND
  71:main.c        **** #define BLPNUM		PIND7
  72:main.c        **** 
  73:main.c        **** 
  74:main.c        **** /*
  75:main.c        ****  * Выбор порта для индикатора работы загрузчика
  76:main.c        ****  * Светодиод горит - мы в загрузчике
  77:main.c        ****  */
  78:main.c        **** /*
  79:main.c        **** #define ENABLE_BOOT_LED
  80:main.c        **** #define BIPORT		PORTD
  81:main.c        **** #define BIDDR		DDRD
  82:main.c        **** #define BIPIN		PIND
  83:main.c        **** #define BIPNUM		PIND5
  84:main.c        **** */
  85:main.c        **** 
  86:main.c        **** /*
  87:main.c        ****  * Выключить Собачий таймер на время загрузчика
  88:main.c        ****  */
  89:main.c        **** #define DISABLE_WDT_AT_STARTUP
  90:main.c        **** 
  91:main.c        **** /*
  92:main.c        ****  * Watchdog-reset is issued at exit 
  93:main.c        ****  * define the timeout-value here (see avr-libc manual)
  94:main.c        ****  */
  95:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  96:main.c        **** 
  97:main.c        **** /*
  98:main.c        ****  * Выбор режима загрузчика
  99:main.c        ****  * SIMPLE-Mode - Загрузчик стартует когда нажата его кнопка
 100:main.c        ****  *   переход к основной программе осуществляется после сброса 
 101:main.c        ****  *   (кнопка должна быть отжата) либо по команде от программатора
 102:main.c        ****  *   При этом режиме вывод на кнопку конфигурируется как вход-с подтягом,
 103:main.c        ****  *   но при выходе из загрузчика все выставляется по умолчанию
 104:main.c        ****  * POWERSAVE-Mode - Startup is separated in two loops
 105:main.c        ****  *   which makes power-saving a little easier if no firmware
 106:main.c        ****  *   is on the chip. Needs more memory
 107:main.c        ****  * BOOTICE-Mode - для зашивки  JTAGICE файла upgrade.ebn в Мегу16.
 108:main.c        ****  *   что превращает ее в JTAG отладчик. Разумеется нужно добавить весь необходимый
 109:main.c        ****  *   обвяз на кристалл для этого. И частота должна быть везде прописана как 7372800
 110:main.c        ****  *   в F_CPU Для совместимости с родной прошивкой JTAG ICE
 111:main.c        ****  * WAIT-mode Bootloader ожидает команды на вход, если ее не было в течении промежутка времени
 112:main.c        ****  *   (который настраивается) то проихсодит переход к основной программе.
 113:main.c        ****  */
 114:main.c        **** //#define START_SIMPLE
 115:main.c        **** #define START_WAIT
 116:main.c        **** //#define START_POWERSAVE
 117:main.c        **** //#define START_BOOTICE
 118:main.c        **** 
 119:main.c        **** /* Команда для входа в загрузчик в START_WAIT */
 120:main.c        **** #define START_WAIT_UARTCHAR 'S'
 121:main.c        **** 
 122:main.c        **** /* Выдержка для START_WAIT mode ( t = WAIT_TIME * 10ms ) */
 123:main.c        **** #define WAIT_VALUE 1000 /* сейчас: 1000*10ms = 10000ms = 10sec */
 124:main.c        **** 
 125:main.c        **** /*
 126:main.c        ****  * enable/disable readout of fuse and lock-bits
 127:main.c        ****  * (AVRPROG has to detect the AVR correctly by device-code
 128:main.c        ****  * to show the correct information).
 129:main.c        ****  */
 130:main.c        **** //#define ENABLEREADFUSELOCK
 131:main.c        **** 
 132:main.c        **** /* enable/disable write of lock-bits
 133:main.c        ****  * WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 134:main.c        ****  * Only protection no unprotection, "chip erase" from bootloader only
 135:main.c        ****  * clears the flash but does no real "chip erase" (this is not possible
 136:main.c        ****  * with a bootloader as far as I know)
 137:main.c        ****  * Keep this undefined!
 138:main.c        ****  */
 139:main.c        **** //#define WRITELOCKBITS
 140:main.c        **** 
 141:main.c        **** /*
 142:main.c        ****  * define the following if the bootloader should not output
 143:main.c        ****  * itself at flash read (will fake an empty boot-section)
 144:main.c        ****  */
 145:main.c        **** //#define READ_PROTECT_BOOTLOADER 
 146:main.c        **** 
 147:main.c        **** #define VERSION_HIGH '0'
 148:main.c        **** #define VERSION_LOW  '8'
 149:main.c        **** 
 150:main.c        **** #define GET_LOCK_BITS           0x0001
 151:main.c        **** #define GET_LOW_FUSE_BITS       0x0000
 152:main.c        **** #define GET_HIGH_FUSE_BITS      0x0003
 153:main.c        **** #define GET_EXTENDED_FUSE_BITS  0x0002
 154:main.c        **** 
 155:main.c        **** /* Расчет делителя частоты для USART*/
 156:main.c        **** #ifdef UART_DOUBLESPEED
 157:main.c        **** 
 158:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 4UL)) / ((uint32_
 159:main.c        **** 
 160:main.c        **** #else
 161:main.c        **** 
 162:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 8UL)) / ((uint32_
 163:main.c        **** 
 164:main.c        **** #endif
 165:main.c        **** 
 166:main.c        **** 
 167:main.c        **** #include <stdint.h>
 168:main.c        **** #include <avr/io.h>
 169:main.c        **** #include <avr/wdt.h>
 170:main.c        **** #include <avr/boot.h>
 171:main.c        **** #include <avr/pgmspace.h>
 172:main.c        **** #include <avr/eeprom.h>
 173:main.c        **** #include <avr/interrupt.h>
 174:main.c        **** #include <util/delay.h>
 175:main.c        **** 
 176:main.c        **** #include "chipdef.h"
 177:main.c        **** 
 178:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 179:main.c        **** 
 180:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 181:main.c        **** 	#warning "This Bootloader does not link interrupt vectors - see makefile"
 182:main.c        **** 	/* make the linker happy - it wants to see __vector_default */
 183:main.c        **** 	// void __vector_default(void) { ; }
 184:main.c        **** 	void __vector_default(void) { ; }
  97               	tabn	68,0,184,.LM0-.LFBB1
  98               	.LM0:
  99               	.LFBB1:
 100               	/* prologue: function */
 101               	/* frame size = 0 */
 102               	/* epilogue start */
 104               	.LM1:
 105 0000 0895      		ret
 107               	.Lscope1:
 110               	send_boot:
 185:main.c        **** T_STATUS & (1<<UART_TXREADY)));
 186:main.c        **** 	UART_DATA = data;
 187:main.c        **** }
 188:main.c        **** 
 189:main.c        **** static uint8_t recvchar(void)
 190:main.c        **** {
 191:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)));
 192:main.c        **** 	return UART_DATA;
 193:main.c        **** }
 194:main.c        **** 
 195:main.c        **** static inline void eraseFlash(void)
 196:main.c        **** {
 197:main.c        **** 	// erase only main section (bootloader protection)
 198:main.c        **** 	uint32_t addr = 0;
 199:main.c        **** 	while (APP_END > addr) 
 200:main.c        **** 		{
 201:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 202:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 203:main.c        **** 		addr += SPM_PAGESIZE;
 204:main.c        **** 		}
 205:main.c        **** 	boot_rww_enable();
 206:main.c        **** }
 207:main.c        **** 
 208:main.c        **** static inline void recvBuffer(pagebuf_t size)
 209:main.c        **** {
 210:main.c        **** 	pagebuf_t cnt;
 211:main.c        **** 	uint8_t *tmp = gBuffer;
 212:main.c        **** 
 213:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) 
 214:main.c        **** 		{
 215:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 216:main.c        **** 		}
 217:main.c        **** }
 218:main.c        **** 
 219:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 220:main.c        **** {
 221:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 222:main.c        **** 	uint32_t baddr = pagestart;
 223:main.c        **** 	uint16_t data;
 224:main.c        **** 	uint8_t *tmp = gBuffer;
 225:main.c        **** 
 226:main.c        **** 	do 
 227:main.c        **** 		{
 228:main.c        **** 		data = *tmp++;
 229:main.c        **** 		data |= *tmp++ << 8;
 230:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 231:main.c        **** 
 232:main.c        **** 		baddr += 2;			// Select next word in memory
 233:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 234:main.c        **** 		} 
 235:main.c        **** 	while (size);				// Loop until all bytes written
 236:main.c        **** 
 237:main.c        **** 	boot_page_write(pagestart);
 238:main.c        **** 	boot_spm_busy_wait();
 239:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 240:main.c        **** 
 241:main.c        **** 	return baddr>>1;
 242:main.c        **** }
 243:main.c        **** 
 244:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 245:main.c        **** {
 246:main.c        **** 	uint8_t *tmp = gBuffer;
 247:main.c        **** 
 248:main.c        **** 	do 
 249:main.c        **** 		{
 250:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 251:main.c        **** 		address++;			// Select next byte
 252:main.c        **** 		size--;				// Decreas number of bytes to write
 253:main.c        **** 		}
 254:main.c        **** 	while (size);				// Loop until all bytes written
 255:main.c        **** 
 256:main.c        **** 	// eeprom_busy_wait();
 257:main.c        **** 
 258:main.c        **** 	return address;
 259:main.c        **** }
 260:main.c        **** 
 261:main.c        **** static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
 262:main.c        **** {
 263:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 264:main.c        **** 	uint16_t data;
 265:main.c        **** 
 266:main.c        **** 	do 
 267:main.c        **** 	{
 268:main.c        **** 
 269:main.c        **** #ifndef READ_PROTECT_BOOTLOADER
 270:main.c        **** #warning "Bootloader not read-protected"
 271:main.c        **** 
 272:main.c        **** 	#if defined(RAMPZ)
 273:main.c        **** 		data = pgm_read_word_far(baddr);
 274:main.c        **** 	#else
 275:main.c        **** 		data = pgm_read_word_near(baddr);
 276:main.c        **** 	#endif
 277:main.c        **** 
 278:main.c        **** #else
 279:main.c        **** 		// don't read bootloader
 280:main.c        **** 		if ( baddr < APP_END ) 
 281:main.c        **** 		{
 282:main.c        **** 		#if defined(RAMPZ)
 283:main.c        **** 			data = pgm_read_word_far(baddr);
 284:main.c        **** 		#else
 285:main.c        **** 			data = pgm_read_word_near(baddr);
 286:main.c        **** 		#endif
 287:main.c        **** 		}
 288:main.c        **** 		else 
 289:main.c        **** 		{
 290:main.c        **** 		data = 0xFFFF; // fake empty
 291:main.c        **** 		}
 292:main.c        **** #endif
 293:main.c        **** 		sendchar(data);			// send LSB
 294:main.c        **** 		sendchar((data >> 8));		// send MSB
 295:main.c        **** 		baddr += 2;			// Select next word in memory
 296:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 297:main.c        **** 	} 
 298:main.c        **** 	while (size);				// Repeat until block has been read
 299:main.c        **** 	return baddr>>1;
 300:main.c        **** }
 301:main.c        **** 
 302:main.c        **** static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
 303:main.c        **** {
 304:main.c        **** 	do 
 305:main.c        **** 	{
 306:main.c        **** 	sendchar( eeprom_read_byte( (uint8_t*)address ) );
 307:main.c        **** 	address++;
 308:main.c        **** 	size--;				// Decrease number of bytes to read
 309:main.c        **** 	} 
 310:main.c        **** 	while (size);				// Repeat until block has been read
 311:main.c        **** 
 312:main.c        **** 	return address;
 313:main.c        **** }
 314:main.c        **** 
 315:main.c        **** #if defined(ENABLEREADFUSELOCK)
 316:main.c        **** static uint8_t read_fuse_lock(uint16_t addr)
 317:main.c        **** {
 318:main.c        **** 	uint8_t mode = (1<<BLBSET) | (1<<SPMEN);
 319:main.c        **** 	uint8_t retval;
 320:main.c        **** 
 321:main.c        **** 	asm volatile
 322:main.c        **** 	(
 323:main.c        **** 		"movw r30, %3\n\t"		/* Z to addr */ \
 324:main.c        **** 		"sts %0, %2\n\t"		/* set mode in SPM_REG */ \
 325:main.c        **** 		"lpm\n\t"			/* load fuse/lock value into r0 */ \
 326:main.c        **** 		"mov %1,r0\n\t"			/* save return value */ \
 327:main.c        **** 		: "=m" (SPM_REG),
 328:main.c        **** 		  "=r" (retval)
 329:main.c        **** 		: "r" (mode),
 330:main.c        **** 		  "r" (addr)
 331:main.c        **** 		: "r30", "r31", "r0"
 332:main.c        **** 	);
 333:main.c        **** 	return retval;
 334:main.c        **** }
 335:main.c        **** #endif
 336:main.c        **** 
 337:main.c        **** static void send_boot(void)
 338:main.c        **** {
 339:main.c        **** 	sendchar('A');
 340:main.c        **** 	sendchar('V');
 341:main.c        **** 	sendchar('R');
 342:main.c        **** 	sendchar('B');
 111               	42,.LM2-.LFBB2
 112               	.LM2:
 113               	.LFBB2:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	.L4:
 117               	.LBB124:
 118               	.LBB125:
 120               	.LM3:
 121 0002 5D9B      		sbis 43-32,5
 122 0004 00C0      		rjmp .L4
 124               	.LM4:
 125 0006 81E4      		ldi r24,lo8(65)
 126 0008 8CB9      		out 44-32,r24
 127               	.L5:
 128               	.LBE125:
 129               	.LBE124:
 130               	.LBB126:
 131               	.LBB127:
 133               	.LM5:
 134 000a 5D9B      		sbis 43-32,5
 135 000c 00C0      		rjmp .L5
 137               	.LM6:
 138 000e 86E5      		ldi r24,lo8(86)
 139 0010 8CB9      		out 44-32,r24
 140               	.L6:
 141               	.LBE127:
 142               	.LBE126:
 143               	.LBB128:
 144               	.LBB129:
 146               	.LM7:
 147 0012 5D9B      		sbis 43-32,5
 148 0014 00C0      		rjmp .L6
 150               	.LM8:
 151 0016 82E5      		ldi r24,lo8(82)
 152 0018 8CB9      		out 44-32,r24
 153               	.L7:
 154               	.LBE129:
 155               	.LBE128:
 156               	.LBB130:
 157               	.LBB131:
 159               	.LM9:
 160 001a 5D9B      		sbis 43-32,5
 161 001c 00C0      		rjmp .L7
 163               	.LM10:
 164 001e 82E4      		ldi r24,lo8(66)
 165 0020 8CB9      		out 44-32,r24
 166               	.L8:
 167               	.LBE131:
 168               	.LBE130:
 169               	.LBB132:
 170               	.LBB133:
 172               	.LM11:
 173 0022 5D9B      		sbis 43-32,5
 174 0024 00C0      		rjmp .L8
 176               	.LM12:
 177 0026 8FE4      		ldi r24,lo8(79)
 178 0028 8CB9      		out 44-32,r24
 179               	.L9:
 180               	.LBE133:
 181               	.LBE132:
 182               	.LBB134:
 183               	.LBB135:
 185               	.LM13:
 186 002a 5D9B      		sbis 43-32,5
 187 002c 00C0      		rjmp .L9
 189               	.LM14:
 190 002e 8FE4      		ldi r24,lo8(79)
 191 0030 8CB9      		out 44-32,r24
 192               	.L10:
 193               	.LBE135:
 194               	.LBE134:
 195               	.LBB136:
 196               	.LBB137:
 198               	.LM15:
 199 0032 5D9B      		sbis 43-32,5
 200 0034 00C0      		rjmp .L10
 202               	.LM16:
 203 0036 84E5      		ldi r24,lo8(84)
 204 0038 8CB9      		out 44-32,r24
 205               	/* epilogue start */
 206               	.LBE137:
 207               	.LBE136:
 343:main.c        **** t device = 0, val;
 344:main.c        **** 
 345:main.c        **** //clear PD5, for PID project bootloader
 346:main.c        **** 	PORTD &= ~(1<<5);
 347:main.c        **** 	DDRD |= (1<<5);
 348:main.c        **** 
 349:main.c        **** #ifdef ENABLE_BOOT_LED	// LED ON
 350:main.c        **** 	BIPORT |= (1<<BIPNUM);	
 208               	(0,1)",36,0,0,main
 209               	.global	main
 211               	main:
 213               	.LM18:
 214               	.LFBB3:
 215               		push r2
 216               		push r3
 351:main.c        **** 	BIDDR  |= (1<<BIPNUM);
 352:main.c        **** #endif
 353:main.c        **** 
 354:main.c        **** 
 355:main.c        **** #ifdef DISABLE_WDT_AT_STARTUP
 217               		push r5
 218               		push r6
 219               		push r7
 220 003c 2F92      		push r8
 221 003e 3F92      		push r9
 222 0040 4F92      		push r10
 223 0042 5F92      		push r11
 224 0044 6F92      		push r12
 225 0046 7F92      		push r13
 226 0048 8F92      		push r14
 227 004a 9F92      		push r15
 228 004c AF92      		push r16
 229 004e BF92      		push r17
 230 0050 CF92      		push r28
 231 0052 DF92      		push r29
 232 0054 EF92      	/* prologue: function */
 233 0056 FF92      	/* frame size = 0 */
 235 005a 1F93      	.LM19:
 236 005c CF93      		cbi 50-32,5
 238               	.LM20:
 239               		sbi 49-32,5
 356:main.c        **** #ifdef WDT_OFF_SPECIAL
 357:main.c        **** 		#warning "using target specific watchdog_off"
 358:main.c        **** 		bootloader_wdt_off();
 359:main.c        **** 	#else
 360:main.c        **** 		cli();
 240               	.LFBB3
 241               	.LM21:
 242 0060 9598      	/* #APP */
 361:main.c        **** _reset();
 243               	 374 "main.c" 1
 244               		cli
 245 0062 8D9A      	 ;  0 "" 2
 362:main.c        **** 	wdt_disable();
 363:main.c        **** 	#endif
 364:main.c        **** #endif
 365:main.c        **** 	
 366:main.c        **** #ifdef START_POWERSAVE
 367:main.c        **** 	uint8_t OK = 1;
 368:main.c        **** #endif
 369:main.c        **** 
 370:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);		// set as Input
 371:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 372:main.c        **** 
 373:main.c        **** 	// Set baud rate
 374:main.c        **** 	UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
 246               	tabn	68,0,375,.LM22-.LFBB3
 247               	.LM22:
 248               	 ;  375 "main.c" 1
 249               		wdr
 250 0064 F894      	 ;  0 "" 2
 375:main.c        **** W = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 252               	
 253               	/* #NOAPP */
 254               		ldi r24,lo8(24)
 255 0066 A895      	/* #APP */
 256               	 ;  376 "main.c" 1
 376:main.c        **** #ifdef UART_DOUBLESPEED
 257               	__tmp_reg__, __SREG__
 258               		cli
 259               		out 33, r24
 260 0068 88E1      		out 33, __zero_reg__
 261               		out __SREG__,__tmp_reg__
 262               		
 263 006a 0FB6      	 ;  0 "" 2
 265 006e 81BD      	.LM24:
 266 0070 11BC      	/* #NOAPP */
 267 0072 0FBE      		cbi 49-32,7
 269               	.LM25:
 377:main.c        **** UART_STATUS = ( 1<<UART_DOUBLE );
 378:main.c        **** #endif
 379:main.c        **** 
 380:main.c        **** 	UART_CTRL = UART_CTRL_DATA;
 381:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 382:main.c        **** 	
 383:main.c        **** #if defined(START_POWERSAVE)
 384:main.c        **** 	/*
 271               	.LM26:
 272               		out 64-32,__zero_reg__
 385:main.c        **** s an adoption of the Butterfly Bootloader startup-sequence.
 274               	7:
 275               		ldi r25,lo8(25)
 276 0076 979A      		out 41-32,r25
 386:main.c        **** 	It may look a little strange but separating the login-loop from
 387:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 388:main.c        **** 	    etc.).
 277               	tabn	68,0,395,.LM28-.LFBB3
 278               	.LM28:
 279 0078 10BC      		out 42-32,r24
 389:main.c        **** 
 280               	tabn	68,0,396,.LM29-.LFBB3
 281               	.LM29:
 282 007a 99E1      		ldi r24,lo8(-122)
 283 007c 99B9      		out 64-32,r24
 390:main.c        **** 	for(;OK;) 
 391:main.c        **** 	{
 392:main.c        **** 		if ((BLPIN & (1<<BLPNUM))) 
 393:main.c        **** 		{
 394:main.c        **** 		// jump to main app if pin is not grounded
 395:main.c        **** 		BLPORT &= ~(1<<BLPNUM);	// set to default
 284               	 r16,lo8(0)
 285               		ldi r17,hi8(0)
 396:main.c        **** #ifdef UART_DOUBLESPEED
 287               	30:
 288               		clr r14
 289 0080 86E8      		clr r15
 290 0082 80BD      	.LBB138:
 291 0084 00E0      	.LBB139:
 292 0086 10E0      	.LBB140:
 397:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 398:main.c        **** 		#endif
 399:main.c        **** 
 400:main.c        **** 
 401:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 402:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 403:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 404:main.c        **** 		#endif
 405:main.c        **** 
 406:main.c        **** 		jump_to_app();		// Jump to application sector
 407:main.c        **** 
 408:main.c        **** 		} 
 409:main.c        **** 		else 
 410:main.c        **** 		{
 411:main.c        **** 		val = recvchar();
 412:main.c        **** 		/* ESC */
 413:main.c        **** 			if (val == 0x1B) 
 414:main.c        **** 			{
 415:main.c        **** 				// AVRPROG connection
 416:main.c        **** 				// Wait for signon
 417:main.c        **** 				while (val != 'S')
 418:main.c        **** 				val = recvchar();
 419:main.c        **** 				
 420:main.c        **** 				send_boot();			// Report signon
 421:main.c        **** 				OK = 0;
 422:main.c        **** 			} 
 423:main.c        **** 			else 
 424:main.c        **** 			{
 425:main.c        **** 			sendchar('?');
 426:main.c        **** 			}
 427:main.c        **** 	    }
 428:main.c        **** 		// Power-Save code here
 429:main.c        **** 	}
 430:main.c        **** 
 431:main.c        **** #elif defined(START_SIMPLE)
 432:main.c        **** 
 433:main.c        **** 	if ((BLPIN & (1<<BLPNUM))) {
 434:main.c        **** 		// jump to main app if pin is not grounded
 435:main.c        **** 		BLPORT &= ~(1<<BLPNUM);		// set to default	
 436:main.c        **** 			
 437:main.c        **** 	#ifdef UART_DOUBLESPEED
 438:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 439:main.c        **** 	#endif
 440:main.c        **** 
 441:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 442:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 443:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 444:main.c        **** 		#endif
 445:main.c        **** 
 446:main.c        **** 		jump_to_app();			// Jump to application sector
 447:main.c        **** 	}
 448:main.c        **** 
 449:main.c        **** #elif defined(START_WAIT)
 450:main.c        **** 
 451:main.c        **** 	uint16_t cnt = 0;
 452:main.c        **** 
 453:main.c        **** 	while (1) {
 454:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 455:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 456:main.c        **** 				break;
 457:main.c        **** 
 458:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 459:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 460:main.c        **** 
 461:main.c        **** 
 462:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 463:main.c        **** 			BIPORT &= ~(1<<BIPNUM);	
 464:main.c        **** 			BIDDR  &= ~(1<<BIPNUM);
 465:main.c        **** 			#endif
 466:main.c        **** 			jump_to_app();			// Jump to application sector
 467:main.c        **** 		}
 468:main.c        **** 
 469:main.c        **** 		_delay_ms(10);
 470:main.c        **** 	}
 471:main.c        **** 	send_boot();
 472:main.c        **** 
 473:main.c        **** #elif defined(START_BOOTICE)
 474:main.c        **** #warning "BOOTICE mode - no startup-condition"
 475:main.c        **** 
 476:main.c        **** #else
 477:main.c        **** #error "Select START_ condition for bootloader in main.c"
 478:main.c        **** #endif
 479:main.c        **** 
 480:main.c        **** 
 481:main.c        **** 	for(;;) 
 482:main.c        **** 	{
 293               	1:
 295 0088 EE24      	.Ltext1:
 297               	.LM31:
 298               		ldi r28,lo8(20000)
 299               		ldi r29,hi8(20000)
 300               	.L23:
 301               	.LBE141:
 302               	.LBE140:
   1:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 303               	LBE138:
 305 008c C0E2      	.Ltext2:
 307               	.LM32:
 308               		sbis 43-32,7
 309               		rjmp .L20
 311               	.LM33:
 312               		in r24,44-32
 313               		cpi r24,lo8(83)
 314               		breq .L21
 315               	.L20:
 317 0092 00C0      	.LM34:
 318               		ldi r18,hi8(1000)
 319               		cpi r16,lo8(1000)
 320 0094 8CB1      		cpc r17,r18
 321 0096 8335      		brlo .L22
 323               	.LM35:
 324               		cbi 50-32,7
 326 009a 23E0      	.LM36:
 327 009c 083E      		movw r30,r14
 328 009e 1207      		icall
 329 00a0 00F0      	.L22:
 331               	.LM37:
 332 00a2 9798      		subi r16,lo8(-(1))
 333               		sbci r17,hi8(-(1))
 334               	.LBB145:
 335 00a4 F701      	.LBB144:
 336 00a6 0995      	.LBB143:
 337               	.LBB142:
 339               	.Ltext3:
 341 00aa 1F4F      	.LM38:
 342               		movw r24,r28
 343               	/* #APP */
 344               	 ;  105 "c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h" 1
 345               		1: sbiw r24,1
 346               		brne 1b
 347               	 ;  0 "" 2
 348               	/* #NOAPP */
 349               		rjmp .L23
 350 00ac CE01      	.L21:
 351               	.LBE142:
 352               	.LBE143:
 353 00ae 0197      	.LBE144:
 354 00b0 01F4      	.LBE145:
 356               	.Ltext4:
 358               	.LM39:
 359               		call send_boot
 360               		clr r5
 361               		clr r10
 362               		clr r11
 363               	.LBB146:
 364               	.LBB147:
 483:main.c        **** 
 484:main.c        **** 		{
 485:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 486:main.c        **** 
 487:main.c        **** 		//write address
 365               	,r26
 366               	.LBE147:
 367 00b4 0E94 0000 	.LBE146:
 368 00b8 5524      	.LBB149:
 369 00ba AA24      	.LBB150:
 370 00bc BB24      		ldi r31,lo8(3)
 371               		mov r4,r31
 372               	.LBE150:
 373               	.LBE149:
 375 00be ADE0      	.LM41:
 376 00c0 CA2E      		ldi r30,lo8(24)
 377               		mov r2,r30
 378               		mov r3,__zero_reg__
 379               	.L153:
 380               	.LBB152:
 381 00c2 F3E0      	.LBB153:
 383               	.LM42:
 384               		sbis 43-32,7
 488:main.c        **** {
 489:main.c        **** 		val = recvchar();
 490:main.c        **** 		// Autoincrement?
 491:main.c        **** 		if (val == 'a') 
 492:main.c        **** 		{
 493:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 494:main.c        **** 
 495:main.c        **** 		//write address
 496:main.c        **** 		} 
 497:main.c        **** 		else if (val == 'A') 
 498:main.c        **** 		{
 499:main.c        **** 			address = recvchar();		//read address 8 MSB
 500:main.c        **** 			address = (address<<8) | recvchar();
 501:main.c        **** 			sendchar('\r');
 502:main.c        **** 
 503:main.c        **** 		// Buffer load support
 504:main.c        **** 		} 
 505:main.c        **** 		else if (val == 'b') 
 506:main.c        **** 		{
 507:main.c        **** 			sendchar('Y');					// Report buffer load supported
 508:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 509:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 510:main.c        **** 
 511:main.c        **** 		// Start buffer load
 512:main.c        **** 		} 
 513:main.c        **** 		else if (val == 'B') 
 514:main.c        **** 		{
 515:main.c        **** 			pagebuf_t size;
 516:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 517:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 518:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 519:main.c        **** 			recvBuffer(size);
 520:main.c        **** 
 521:main.c        **** 			if (device == DEVTYPE) 
 522:main.c        **** 			{
 523:main.c        **** 				if (val == 'F') 
 524:main.c        **** 				{
 525:main.c        **** 				address = writeFlashPage(address, size);
 526:main.c        **** 				} 
 527:main.c        **** 				else if (val == 'E') 
 528:main.c        **** 				{
 529:main.c        **** 				address = writeEEpromPage(address, size);
 530:main.c        **** 				}
 531:main.c        **** 				sendchar('\r');
 532:main.c        **** 			} 
 533:main.c        **** 			else 
 534:main.c        **** 			{
 535:main.c        **** 			sendchar(0);
 536:main.c        **** 			}
 537:main.c        **** 
 538:main.c        **** 		// Block read
 539:main.c        **** 		} 
 540:main.c        **** 		else if (val == 'g') 
 541:main.c        **** 		{
 542:main.c        **** 			pagebuf_t size;
 543:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 544:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 545:main.c        **** 			val = recvchar();				// Get memtype
 546:main.c        **** 
 547:main.c        **** 			if (val == 'F') 
 548:main.c        **** 			{
 549:main.c        **** 			address = readFlashPage(address, size);
 550:main.c        **** 			} 
 551:main.c        **** 			else if (val == 'E') 
 552:main.c        **** 			{
 553:main.c        **** 			address = readEEpromPage(address, size);
 554:main.c        **** 			}
 555:main.c        **** 
 556:main.c        **** 		// Chip erase
 557:main.c        ****  		} 
 558:main.c        **** 		else if (val == 'e') 
 559:main.c        **** 		{
 560:main.c        **** 		if (device == DEVTYPE) 
 561:main.c        **** 			{
 562:main.c        **** 			eraseFlash();
 563:main.c        **** 			}
 564:main.c        **** 		sendchar('\r');
 565:main.c        **** 
 566:main.c        **** 		// Exit upgrade
 567:main.c        **** 		} 
 568:main.c        **** 		else if (val == 'E') 
 569:main.c        **** 		{
 570:main.c        **** 		wdt_enable(EXIT_WDT_TIME); // Enable Watchdog Timer to give reset
 571:main.c        **** 		sendchar('\r');
 572:main.c        **** 
 573:main.c        **** 		#ifdef WRITELOCKBITS
 574:main.c        **** 			#warning "Extension 'WriteLockBits' enabled"
 575:main.c        **** 			// TODO: does not work reliably
 576:main.c        **** 			// write lockbits
 577:main.c        **** 			} 
 578:main.c        **** 			else if (val == 'l') 
 579:main.c        **** 			{
 580:main.c        **** 			if (device == DEVTYPE) 
 385               	68,0,196,.LM43-.LFBB3
 386               	.LM43:
 387 00c6 E8E1      		in r25,44-32
 388 00c8 2E2E      	.LBE153:
 389 00ca 312C      	.LBE152:
 391               	.LM44:
 392               		cpi r25,lo8(97)
 393               		brne .L25
 394               	.L90:
 395 00cc 5F9B      	.LBB154:
 396 00ce 00C0      	.LBB155:
 398               	.LM45:
 399 00d0 9CB1      		sbis 43-32,5
 400               		rjmp .L90
 402               	.LM46:
 403               		ldi r22,lo8(89)
 404 00d2 9136      		rjmp .L154
 405 00d4 01F4      	.L25:
 406               	.LBE155:
 407               	.LBE154:
 409               	.LM47:
 410               		cpi r25,lo8(65)
 411 00d6 5D9B      		brne .L27
 412 00d8 00C0      	.L91:
 413               	.LBB156:
 414               	.LBB157:
 416 00dc 00C0      	.LM48:
 417               		sbis 43-32,7
 418               		rjmp .L91
 420               	.LM49:
 421               		in r25,44-32
 422 00de 9134      	.L29:
 423 00e0 01F4      	.LBE157:
 424               	.LBE156:
 425               	.LBB158:
 426               	.LBB159:
 428               	.LM50:
 429 00e2 5F9B      		sbis 43-32,7
 430 00e4 00C0      		rjmp .L29
 432               	.LM51:
 433 00e6 9CB1      		in r24,44-32
 434               	.L30:
 435               	.LBE159:
 436               	.LBE158:
 437               	.LBB160:
 438               	.LBB148:
 440               	.LM52:
 441 00e8 5F9B      		sbis 43-32,5
 442 00ea 00C0      		rjmp .L30
 443               	.LBE148:
 444               	.LBE160:
 446               	.LM53:
 447               		mov r7,r25
 448               		clr r6
 449               		mov r10,r24
 450               		clr r11
 451               		or r10,r6
 452               		or r11,r7
 453 00ee 5D9B      		rjmp .L159
 454 00f0 00C0      	.L27:
 456               	.LM54:
 457               		cpi r25,lo8(98)
 458               		brne .L31
 459 00f2 792E      	.L92:
 460 00f4 6624      	.LBB161:
 461 00f6 A82E      	.LBB162:
 463 00fa A628      	.LM55:
 464 00fc B728      		sbis 43-32,5
 465 00fe 00C0      		rjmp .L92
 467               	.LM56:
 468               		ldi r24,lo8(89)
 469 0100 9236      		out 44-32,r24
 470 0102 01F4      	.L33:
 471               	.LBE162:
 472               	.LBE161:
 473               	.LBB163:
 474               	.LBB164:
 476 0104 5D9B      	.LM57:
 477 0106 00C0      		sbis 43-32,5
 478               		rjmp .L33
 480 0108 89E5      	.LM58:
 481 010a 8CB9      		out 44-32,__zero_reg__
 482               	.L34:
 483               	.LBE164:
 484               	.LBE163:
 485               	.LBB165:
 486               	.LBB166:
 488               	.LM59:
 489 010c 5D9B      		sbis 43-32,5
 490 010e 00C0      		rjmp .L34
 492               	.LM60:
 493 0110 1CB8      		ldi r30,lo8(-128)
 494               		rjmp .L156
 495               	.L31:
 496               	.LBE166:
 497               	.LBE165:
 499               	.LM61:
 500               		cpi r25,lo8(66)
 501 0112 5D9B      		breq .+2
 502 0114 00C0      		rjmp .L35
 503               	.L96:
 504               	.LBB167:
 505 0116 E0E8      	.LBB168:
 506 0118 00C0      	.LBB169:
 508               	.LM62:
 509               		sbis 43-32,7
 510               		rjmp .L96
 512 011a 9234      	.LM63:
 513 011c 01F0      		in r24,44-32
 514 011e 00C0      	.L37:
 515               	.LBE169:
 516               	.LBE168:
 517               	.LBB170:
 518               	.LBB171:
 520               	.LM64:
 521 0120 5F9B      		sbis 43-32,7
 522 0122 00C0      		rjmp .L37
 524               	.LM65:
 525 0124 8CB1      		in r13,44-32
 526               	.L38:
 527               	.LBE171:
 528               	.LBE170:
 529               	.LBB172:
 530               	.LBB173:
 532               	.LM66:
 533 0126 5F9B      		sbis 43-32,7
 534 0128 00C0      		rjmp .L38
 536               	.LM67:
 537 012a DCB0      		in r18,44-32
 538               		ldi r24,lo8(0)
 539               		ldi r30,lo8(gBuffer)
 540               		ldi r31,hi8(gBuffer)
 541               	.L41:
 542               	.LBE173:
 543               	.LBE172:
 544               	.LBB174:
 545 012c 5F9B      	.LBB175:
 547               	.LM68:
 548               		cp r24,r13
 549 0130 2CB1      		brlo .L95
 550 0132 80E0      		ldi r25,lo8(-1)
 551 0134 E0E0      		rjmp .L40
 552 0136 F0E0      	.L95:
 553               	.LBB176:
 554               	.LBB177:
 556               	.LM69:
 557               		sbis 43-32,7
 558               		rjmp .L95
 560 0138 8D15      	.LM70:
 561 013a 00F0      		in r25,44-32
 562 013c 9FEF      	.L40:
 563 013e 00C0      	.LBE177:
 564               	.LBE176:
 566               	.LM71:
 567               		st Z+,r25
 569 0140 5F9B      	.LM72:
 570 0142 00C0      		subi r24,lo8(-(1))
 571               		cpi r24,lo8(-128)
 572               		brne .L41
 573 0144 9CB1      	.LBE175:
 574               	.LBE174:
 576               	.LM73:
 577               		ldi r31,lo8(117)
 578               		cp r5,r31
 579 0146 9193      		breq .+2
 580               		rjmp .L94
 582 0148 8F5F      	.LM74:
 583 014a 8038      		cpi r18,lo8(70)
 584 014c 01F4      		breq .+2
 585               		rjmp .L43
 586               	.LBB178:
 587               	.LBB179:
 589 014e F5E7      	.LM75:
 590 0150 5F16      		movw r14,r10
 591 0152 01F0      		ldi r16,lo8(0)
 592 0154 00C0      		ldi r17,hi8(0)
 593               		lsl r14
 594               		rol r15
 595 0156 2634      		rol r16
 596 0158 01F0      		rol r17
 597 015a 00C0      		movw r20,r16
 598               		movw r18,r14
 599               		ldi r26,lo8(gBuffer)
 600               		ldi r27,hi8(gBuffer)
 601               	.L44:
 603 015e 00E0      	.LM76:
 604 0160 10E0      		ld r24,X
 605 0162 EE0C      		ldi r25,lo8(0)
 607 0166 001F      	.LM77:
 608 0168 111F      		adiw r26,1
 609 016a A801      		ld r9,X
 610 016c 9701      		sbiw r26,1
 611 016e A0E0      		clr r8
 612 0170 B0E0      		or r24,r8
 613               		or r25,r9
 615               	.LM78:
 616 0172 8C91      		adiw r26,2
 618               	.LM79:
 619               		ldi r22,lo8(1)
 620 0176 1196      		movw r30,r18
 621 0178 9C90      	/* #APP */
 622 017a 1197      	 ;  234 "main.c" 1
 623 017c 8824      		movw  r0, r24
 624 017e 8829      		sts 87, r22
 625 0180 9929      		spm
 626               		clr  r1
 627               		
 628 0182 1296      	 ;  0 "" 2
 630               	.LM80:
 631 0184 61E0      	/* #NOAPP */
 632 0186 F901      		subi r18,lo8(-(2))
 633               		sbci r19,hi8(-(2))
 634               		sbci r20,hlo8(-(2))
 635 0188 0C01      		sbci r21,hhi8(-(2))
 637 018e E895      	.LM81:
 638 0190 1124      		ldi r24,lo8(-2)
 639               		add r13,r24
 641               	.LM82:
 642               		brne .L44
 644 0192 2E5F      	.LM83:
 645 0194 3F4F      		ldi r22,lo8(5)
 646 0196 4F4F      		movw r30,r14
 647 0198 5F4F      	/* #APP */
 648               	 ;  241 "main.c" 1
 649               		sts 87, r22
 650 019a 8EEF      		spm
 651 019c D80E      		
 652               	 ;  0 "" 2
 653               	/* #NOAPP */
 654 019e 01F4      	.L45:
 655               	.LBE179:
 657 01a0 65E0      	.LM84:
 658 01a2 F701      		in __tmp_reg__,87-32
 659               		sbrc __tmp_reg__,0
 660               		rjmp .L45
 661 01a4 6093 5700 	.LBB180:
 663               	.LM85:
 664               		ldi r24,lo8(17)
 665               	/* #APP */
 666               	 ;  243 "main.c" 1
 667               		sts 87, r24
 668               		spm
 669               		
 670 01aa 07B6      	 ;  0 "" 2
 672 01ae 00C0      	.LM86:
 673               	/* #NOAPP */
 674               		lsr r21
 675               		ror r20
 676 01b0 81E1      		ror r19
 677               		ror r18
 678               		movw r10,r18
 679 01b2 8093 5700 		rjmp .L93
 680 01b6 E895      	.L43:
 681               	.LBE180:
 682               	.LBE178:
 684               	.LM87:
 685               		cpi r18,lo8(69)
 686 01b8 5695      		brne .L93
 687 01ba 4795      		mov r15,r13
 688 01bc 3795      		movw r16,r10
 689 01be 2795      		ldi r28,lo8(gBuffer)
 690 01c0 5901      		ldi r29,hi8(gBuffer)
 691 01c2 00C0      	.L47:
 692               	.LBB181:
 693               	.LBB182:
 695               	.LM88:
 696               		ld r22,Y+
 697 01c4 2534      		movw r24,r16
 698 01c6 01F4      		call __eewr_byte_m16
 700 01ca 8501      	.LM89:
 701 01cc C0E0      		subi r16,lo8(-(1))
 702 01ce D0E0      		sbci r17,hi8(-(1))
 704               	.LM90:
 705               		dec r15
 707               	.LM91:
 708 01d0 6991      		brne .L47
 709 01d2 C801      		dec r13
 710 01d4 0E94 0000 		mov r24,r13
 711               		ldi r25,lo8(0)
 712               		adiw r24,1
 713 01d8 0F5F      		add r10,r24
 714 01da 1F4F      		adc r11,r25
 715               	.L93:
 716               	.LBE182:
 717 01dc FA94      	.LBE181:
 718               	.LBB183:
 719               	.LBB184:
 721 01e0 DA94      	.LM92:
 722 01e2 8D2D      		sbis 43-32,5
 723 01e4 90E0      		rjmp .L93
 724 01e6 0196      		rjmp .L159
 725 01e8 A80E      	.L94:
 726 01ea B91E      	.LBE184:
 727               	.LBE183:
 728               	.LBB185:
 729               	.LBB186:
 730               		sbis 43-32,5
 731               		rjmp .L94
 732               		rjmp .L158
 733               	.L35:
 734 01ec 5D9B      	.LBE186:
 735 01ee 00C0      	.LBE185:
 736 01f0 00C0      	.LBE167:
 738               	.LM93:
 739               		cpi r25,lo8(103)
 740               		breq .+2
 741               		rjmp .L48
 742 01f2 5D9B      	.L97:
 743 01f4 00C0      	.LBB187:
 744 01f6 00C0      	.LBB188:
 745               	.LBB189:
 747               	.LM94:
 748               		sbis 43-32,7
 749               		rjmp .L97
 751 01f8 9736      	.LM95:
 752 01fa 01F0      		in r24,44-32
 753 01fc 00C0      	.L50:
 754               	.LBE189:
 755               	.LBE188:
 756               	.LBB190:
 757               	.LBB191:
 759               	.LM96:
 760 01fe 5F9B      		sbis 43-32,7
 761 0200 00C0      		rjmp .L50
 763               	.LM97:
 764 0202 8CB1      		in r15,44-32
 765               	.L51:
 766               	.LBE191:
 767               	.LBE190:
 768               	.LBB192:
 769               	.LBB193:
 771               	.LM98:
 772 0204 5F9B      		sbis 43-32,7
 773 0206 00C0      		rjmp .L51
 775               	.LM99:
 776 0208 FCB0      		in r24,44-32
 777               	.LBE193:
 778               	.LBE192:
 780               	.LM100:
 781               		cpi r24,lo8(70)
 782               		brne .L52
 783               	.LBB194:
 784 020a 5F9B      	.LBB195:
 786               	.LM101:
 787               		movw r24,r10
 788 020e 8CB1      		ldi r26,lo8(0)
 789               		ldi r27,hi8(0)
 790               		lsl r24
 791               		rol r25
 792               		rol r26
 793 0210 8634      		rol r27
 794 0212 01F4      	.L55:
 795               	.LBB196:
 797               	.LM102:
 798               		movw r30,r24
 799 0214 C501      	/* #APP */
 800 0216 A0E0      	 ;  279 "main.c" 1
 801 0218 B0E0      		lpm r18, Z+
 802 021a 880F      		lpm r19, Z
 803 021c 991F      		
 804 021e AA1F      	 ;  0 "" 2
 805 0220 BB1F      	/* #NOAPP */
 806               	.L53:
 807               	.LBE196:
 808               	.LBB197:
 809               	.LBB198:
 811               	.LM103:
 812               		sbis 43-32,5
 813 0224 2591      		rjmp .L53
 815               	.LM104:
 816               		out 44-32,r18
 817               	.L54:
 818               	.LBE198:
 819               	.LBE197:
 820               	.LBB199:
 821               	.LBB200:
 823               	.LM105:
 824 0228 5D9B      		sbis 43-32,5
 825 022a 00C0      		rjmp .L54
 827               	.LM106:
 828 022c 2CB9      		out 44-32,r19
 829               	.LBE200:
 830               	.LBE199:
 832               	.LM107:
 833               		adiw r24,2
 834               		adc r26,__zero_reg__
 835               		adc r27,__zero_reg__
 837 0230 00C0      	.LM108:
 838               		ldi r30,lo8(-2)
 839               		add r15,r30
 841               	.LM109:
 842               		brne .L55
 844               	.LM110:
 845 0234 0296      		lsr r27
 846 0236 A11D      		ror r26
 847 0238 B11D      		ror r25
 848               		ror r24
 849               		movw r10,r24
 850 023a EEEF      		rjmp .L153
 851 023c FE0E      	.L52:
 852               	.LBE195:
 853               	.LBE194:
 855               	.LM111:
 856               		cpi r24,lo8(69)
 857 0240 B695      		breq .+2
 858 0242 A795      		rjmp .L153
 859 0244 9795      		mov r14,r15
 860 0246 8795      		movw r16,r10
 861 0248 5C01      	.L57:
 862 024a 00C0      	.LBB201:
 864               	.LM112:
 865               		movw r24,r16
 866               		call __eerd_byte_m16
 867               	.L56:
 868 024c 8534      	.LBB202:
 869 024e 01F0      	.LBB203:
 870 0250 00C0      	.LBB204:
 872 0254 8501      	.LM113:
 873               		sbis 43-32,5
 874               		rjmp .L56
 876               	.LM114:
 877 0256 C801      		out 44-32,r24
 878 0258 0E94 0000 	.LBE204:
 879               	.LBE203:
 881               	.LM115:
 882               		subi r16,lo8(-(1))
 883               		sbci r17,hi8(-(1))
 885 025c 5D9B      	.LM116:
 886 025e 00C0      		dec r14
 888               	.LM117:
 889 0260 8CB9      		brne .L57
 890               		dec r15
 891               		mov r24,r15
 892               		ldi r25,lo8(0)
 893               		adiw r24,1
 894 0262 0F5F      		add r10,r24
 895 0264 1F4F      		adc r11,r25
 896               		rjmp .L153
 897               	.L48:
 898 0266 EA94      	.LBE202:
 899               	.LBE201:
 900               	.LBE187:
 902 026a FA94      	.LM118:
 903 026c 8F2D      		cpi r25,lo8(101)
 904 026e 90E0      		brne .L58
 906 0272 A80E      	.LM119:
 907 0274 B91E      		ldi r31,lo8(117)
 908 0276 00C0      		cp r5,r31
 909               		brne .L98
 910               		ldi r30,lo8(0)
 911               		ldi r31,hi8(0)
 912               	.L61:
 913               	.LBB205:
 914               	.LBB206:
 916 027a 01F4      	.LM120:
 917               	/* #APP */
 918               	 ;  205 "main.c" 1
 919 027c F5E7      		sts 87, r4
 920 027e 5F16      		spm
 921 0280 01F4      		
 922 0282 E0E0      	 ;  0 "" 2
 923 0284 F0E0      	/* #NOAPP */
 924               	.L60:
 925               	.LBE206:
 927               	.LM121:
 928               		in __tmp_reg__,87-32
 929               		sbrc __tmp_reg__,0
 930               		rjmp .L60
 931 0286 4092 5700 		subi r30,lo8(-(128))
 932 028a E895      		sbci r31,hi8(-(128))
 933               	.LBB207:
 935               	.LM122:
 936               		ldi r18,hi8(15360)
 937               		cpi r30,lo8(15360)
 938               		cpc r31,r18
 939               		brne .L61
 941 028e 00FC      	.LM123:
 942 0290 00C0      		ldi r22,lo8(17)
 943 0292 E058      	/* #APP */
 944 0294 FF4F      	 ;  209 "main.c" 1
 945               		sts 87, r22
 946               		spm
 947               		
 948 0296 2CE3      	 ;  0 "" 2
 949 0298 E030      	/* #NOAPP */
 950 029a F207      	.L98:
 951 029c 01F4      	.LBE207:
 952               	.LBE205:
 953               	.LBB208:
 954 029e 61E1      	.LBB209:
 956               	.LM124:
 957 02a0 6093 5700 		sbis 43-32,5
 958 02a4 E895      		rjmp .L98
 959               		rjmp .L159
 960               	.L58:
 961               	.LBE209:
 962               	.LBE208:
 964               	.LM125:
 965               		cpi r25,lo8(69)
 966               		brne .L62
 968               	.LM126:
 969 02a6 5D9B      		ldi r24,lo8(12)
 970 02a8 00C0      	/* #APP */
 971 02aa 00C0      	 ;  580 "main.c" 1
 972               		in __tmp_reg__,__SREG__
 973               		cli
 974               		wdr
 975               		out 33,r2
 976               		out __SREG__,__tmp_reg__
 977 02ac 9534      		out 33,r24
 978 02ae 01F4      	 ;  0 "" 2
 979               	/* #NOAPP */
 980               	.L63:
 981 02b0 8CE0      	.LBB210:
 982               	.LBB211:
 984 02b2 0FB6      	.LM127:
 985 02b4 F894      		sbis 43-32,5
 986 02b6 A895      		rjmp .L63
 987 02b8 21BC      		rjmp .L159
 988 02ba 0FBE      	.L62:
 989 02bc 81BD      	.LBE211:
 990               	.LBE210:
 992               	.LM128:
 993               		cpi r25,lo8(80)
 994               		brne .L64
 995               	.L99:
 996               	.LBB212:
 997 02be 5D9B      	.LBB213:
 999 02c2 00C0      	.LM129:
 1000               		sbis 43-32,5
 1001               		rjmp .L99
 1002               		rjmp .L159
 581:main.c        **** ckbits
 582:main.c        **** 			} 
 583:main.c        **** 			else if (val == 'l') 
 584:main.c        **** 			{
 585:main.c        **** 			if (device == DEVTYPE) 
 586:main.c        **** 				{
 587:main.c        **** 				// write_lock_bits(recvchar());
 588:main.c        **** 				boot_lock_bits_set(recvchar());	// boot.h takes care of mask
 589:main.c        **** 				boot_spm_busy_wait();
 590:main.c        **** 				}
 591:main.c        **** 			sendchar('\r');
 592:main.c        **** 		#endif
 593:main.c        **** 		// Enter programming mode
 594:main.c        **** 		} 
 595:main.c        **** 		else if (val == 'P') 
 596:main.c        **** 		{
 597:main.c        **** 		sendchar('\r');
 598:main.c        **** 
 599:main.c        **** 		// Leave programming mode
 600:main.c        **** 		} 
 1003               	:
 1004               	.LBE212:
 1006 02c6 01F4      	.LM130:
 1007               		cpi r25,lo8(76)
 1008               		brne .L66
 1009               	.L100:
 1010               	.LBB214:
 1011               	.LBB215:
 1013 02ca 00C0      	.LM131:
 1014 02cc 00C0      		sbis 43-32,5
 1015               		rjmp .L100
 1016               		rjmp .L159
 1017               	.L66:
 601:main.c        **** ) 
 602:main.c        **** 		{
 603:main.c        **** 		sendchar('\r');
 604:main.c        **** 
 605:main.c        **** 		// Leave programming mode
 606:main.c        **** 		} 
 1018               	4:
 1020 02ce 9C34      	.LM132:
 1021 02d0 01F4      		cpi r25,lo8(112)
 1022               		brne .L68
 1023               	.L101:
 1024               	.LBB216:
 1025               	.LBB217:
 1027 02d2 5D9B      	.LM133:
 1028 02d4 00C0      		sbis 43-32,5
 1029 02d6 00C0      		rjmp .L101
 1031               	.LM134:
 1032               		ldi r30,lo8(83)
 607:main.c        **** ) 
 608:main.c        **** 		{
 609:main.c        **** 		sendchar('\r');
 610:main.c        **** 
 611:main.c        **** 		// Leave programming mode
 1033               	8:
 1034               	.LBE217:
 1035 02d8 9037      	.LBE216:
 1037               	.LM135:
 1038               		cpi r25,lo8(116)
 1039               		brne .L70
 1040               	.L102:
 1041               	.LBB218:
 1042 02dc 5D9B      	.LBB219:
 1044               	.LM136:
 1045               		sbis 43-32,5
 1046 02e0 E3E5      		rjmp .L102
 1048               	.LM137:
 1049               		ldi r31,lo8(117)
 1050               		out 44-32,r31
 612:main.c        **** == 'P') 
 613:main.c        **** 		{
 614:main.c        **** 		sendchar('\r');
 615:main.c        **** 
 616:main.c        **** 		// Leave programming mode
 617:main.c        **** 		} 
 618:main.c        **** 		else if (val == 'L') 
 619:main.c        **** 		{
 620:main.c        **** 		sendchar('\r');
 621:main.c        **** 		// return programmer type
 622:main.c        **** 		} 
 623:main.c        **** 		else if (val == 'p') 
 624:main.c        **** 		{
 625:main.c        **** 		sendchar('S');		// always serial programmer
 626:main.c        **** 
 627:main.c        **** 		#ifdef ENABLEREADFUSELOCK
 628:main.c        **** 			#warning "Extension 'ReadFuseLock' enabled"
 629:main.c        **** 			// read "low" fuse bits
 630:main.c        **** 			} 
 631:main.c        **** 			else if (val == 'F') 
 632:main.c        **** 			{
 633:main.c        **** 			sendchar(read_fuse_lock(GET_LOW_FUSE_BITS));
 634:main.c        **** 
 635:main.c        **** 			// read lock bits
 636:main.c        **** 			} 
 637:main.c        **** 			else if (val == 'r') 
 638:main.c        **** 			{
 639:main.c        **** 			sendchar(read_fuse_lock(GET_LOCK_BITS));
 640:main.c        **** 
 641:main.c        **** 			// read high fuse bits
 642:main.c        **** 			} 
 643:main.c        **** 			else if (val == 'N') 
 1051               	abn	68,0,643,.LM135-.LFBB3
 1052               	.LM135:
 1053 02e4 9437      		cpi r25,lo8(116)
 1054 02e6 01F4      		brne .L70
 1055               	.L102:
 1056               	.LBB218:
 1057               	.LBB219:
 1059               	.LM136:
 1060 02e8 5D9B      		sbis 43-32,5
 1061 02ea 00C0      		rjmp .L102
 1063               	.LM137:
 1064 02ec F5E7      		ldi r31,lo8(117)
 1065 02ee FCB9      		out 44-32,r31
 1066               	.L72:
 1067               	.LBE219:
 1068               	.LBE218:
 1069               	.LBB220:
 1070               	.LBB221:
 1072               	.LM138:
 1073 02f0 5D9B      		sbis 43-32,5
 1074 02f2 00C0      		rjmp .L72
 1075               	.L158:
 1077               	.LM139:
 1078 02f4 1CB8      		out 44-32,__zero_reg__
 1079 02f6 00C0      		rjmp .L153
 1080               	.L70:
 1081               	.LBE221:
 1082               	.LBE220:
 644:main.c        ****  fuse bits
 645:main.c        **** 			} 
 646:main.c        **** 			else if (val == 'N') 
 647:main.c        **** 			{
 648:main.c        **** 			sendchar(read_fuse_lock(GET_HIGH_FUSE_BITS));
 649:main.c        **** 			// read extended fuse bits
 1083               	2:
 1084               	.LBE219:
 1085 02f8 892F      	.LBE218:
 1086 02fa 8857      	.LBB220:
 1087 02fc 8230      	.LBB221:
 1089               	.LM138:
 1090               		sbis 43-32,5
 1091               		rjmp .L72
 1092               	.L158:
 1094 0300 5F9B      	.LM139:
 1095 0302 00C0      		out 44-32,__zero_reg__
 1096               		rjmp .L153
 1097               	.L70:
 1098 0304 8CB1      	.LBE221:
 1099               	.LBE220:
 1101               	.LM140:
 1102               		mov r24,r25
 1103               		subi r24,lo8(-(-120))
 1104               		cpi r24,lo8(2)
 1105               		brsh .L73
 1106 0306 5D9B      	.L103:
 1107 0308 00C0      	.LBB222:
 1108 030a 00C0      	.LBB223:
 1110               	.LM141:
 1111               		sbis 43-32,7
 650:main.c        **** SE_BITS));
 651:main.c        **** 			// read extended fuse bits
 652:main.c        **** 			} 
 653:main.c        **** 			else if (val == 'Q') 
 654:main.c        **** 			{
 655:main.c        **** 			sendchar(read_fuse_lock(GET_EXTENDED_FUSE_BITS));
 656:main.c        **** 			#endif
 1112               	LBE221:
 1113               	.LBE220:
 1115 030e 01F4      	.LM140:
 1116               		mov r24,r25
 1117               		subi r24,lo8(-(-120))
 1118               		cpi r24,lo8(2)
 1119               		brsh .L73
 1120               	.L103:
 1121 0310 5F9B      	.LBB222:
 1122 0312 00C0      	.LBB223:
 1124               	.LM141:
 1125 0314 5CB0      		sbis 43-32,7
 1126               		rjmp .L103
 1128               	.LM142:
 1129               		in r24,44-32
 1130               	.L75:
 1131               	.LBE223:
 1132               	.LBE222:
 1133 0316 5D9B      	.LBB224:
 1134 0318 00C0      	.LBB225:
 1136               	.LM143:
 1137               		sbis 43-32,5
 1138 031a CCB8      		rjmp .L75
 1139 031c 00C0      		rjmp .L159
 1140               	.L73:
 1141               	.LBE225:
 1142               	.LBE224:
 657:main.c        **** k(GET_EXTENDED_FUSE_BITS));
 658:main.c        **** 			#endif
 659:main.c        **** 
 660:main.c        **** 		// Return device type
 661:main.c        **** 		} 
 662:main.c        **** 		else if (val == 't') 
 1143               	6,.LM142-.LFBB3
 1144               	.LM142:
 1145 031e 9335      		in r24,44-32
 1146 0320 01F4      	.L75:
 663:main.c        **** type
 664:main.c        **** 		} 
 1147               	24,lo8(-(-120))
 1148               		cpi r24,lo8(2)
 1149 0322 0E94 0000 		brsh .L73
 1150 0326 00C0      	.L103:
 1151               	.LBB222:
 665:main.c        **** ndif
 666:main.c        **** 
 667:main.c        **** 		// Return device type
 668:main.c        **** 		} 
 1152               	,.LM139-.LFBB3
 1153               	.LM139:
 1154 0328 9635      		out 44-32,__zero_reg__
 1155 032a 01F4      		rjmp .L153
 1156               	.L70:
 1157               	.LBE221:
 1158               	.LBE220:
 1160               	.LM140:
 1161 032c 5D9B      		mov r24,r25
 1162 032e 00C0      		subi r24,lo8(-(-120))
 1163               		cpi r24,lo8(2)
 1164               		brsh .L73
 1165 0330 20E3      	.L103:
 1166 0332 2CB9      	.LBB222:
 1167               	.LBB223:
 1169               	.LM141:
 1170               		sbis 43-32,7
 1171               		rjmp .L103
 1173               	.LM142:
 1174 0334 5D9B      		in r24,44-32
 1175 0336 00C0      	.L75:
 1176               	.LBE223:
 1177               	.LBE222:
 1178 0338 68E3      	.LBB224:
 1179               	.LBB225:
 1181 033c 00C0      	.LM143:
 1182               		sbis 43-32,5
 1183               		rjmp .L75
 1184               		rjmp .L159
 669:main.c        **** ndif
 670:main.c        **** 
 671:main.c        **** 		// Return device type
 672:main.c        **** 		} 
 673:main.c        **** 		else if (val == 't') 
 674:main.c        **** 		{
 675:main.c        **** 		sendchar(DEVTYPE);
 676:main.c        **** 		sendchar(0);
 1185               		rjmp .L103
 1187 033e 9337      	.LM142:
 1188 0340 01F4      		in r24,44-32
 1189               	.L75:
 1190               	.LBE223:
 1191               	.LBE222:
 1192               	.LBB224:
 1193               	.LBB225:
 1195 0344 00C0      	.LM143:
 1196               		sbis 43-32,5
 1197               		rjmp .L75
 1198 0346 4CB8      		rjmp .L159
 1199               	.L73:
 1200               	.LBE225:
 1201               	.LBE224:
 1203               	.LM144:
 1204               		cpi r25,lo8(84)
 1205               		brne .L76
 1206 0348 5D9B      	.L104:
 1207 034a 00C0      	.LBB226:
 1208               	.LBB227:
 1210 034c 84E9      	.LM145:
 1211 034e 8CB9      		sbis 43-32,7
 1212               		rjmp .L104
 1214               	.LM146:
 1215               		in r5,44-32
 1216               	.L78:
 1217               	.LBE227:
 1218               	.LBE226:
 1219 0350 5D9B      	.LBB228:
 1220 0352 00C0      	.LBB229:
 1222               	.LM147:
 1223 0354 EEE1      		sbis 43-32,5
 1224               		rjmp .L78
 1225 0356 ECB9      	.L159:
 1227               	.LM148:
 1228               		out 44-32,r12
 1229               		rjmp .L153
 677:main.c        **** endchar(DEVTYPE);
 678:main.c        **** 		sendchar(0);
 679:main.c        **** 		// clear and set LED ignored
 680:main.c        **** 		} 
 681:main.c        **** 		else if ((val == 'x') || (val == 'y')) 
 682:main.c        **** 		{
 683:main.c        **** 		recvchar();
 684:main.c        **** 		sendchar('\r');
 1230               	B228:
 1231               	.LBB229:
 1233 035c 01F4      	.LM147:
 1234 035e 00C0      		sbis 43-32,5
 1235               		rjmp .L78
 1236               	.L159:
 1238               	.LM148:
 1239               		out 44-32,r12
 1240 0360 5D9B      		rjmp .L153
 1241 0362 00C0      	.L76:
 1242               	.LBE229:
 1243               	.LBE228:
 1245 0366 FCB9      	.LM149:
 1246 0368 00C0      		cpi r25,lo8(83)
 1247               		brne .L79
 1249               	.LM150:
 1250               		call send_boot
 1251               		rjmp .L153
 1252               	.L79:
 1254               	.LM151:
 1255               		cpi r25,lo8(86)
 1256               		brne .L80
 1257               	.L105:
 1258               	.LBB230:
 1259               	.LBB231:
 1261               	.LM152:
 1262               		sbis 43-32,5
 1263               		rjmp .L105
 1265               	.LM153:
 1266               		ldi r18,lo8(48)
 1267               		out 44-32,r18
 1268               	.L82:
 1269               	.LBE231:
 1270               	.LBE230:
 1271               	.LBB232:
 1272               	.LBB233:
 1274               	.LM154:
 1275               		sbis 43-32,5
 1276               		rjmp .L82
 1278               	.LM155:
 1279               		ldi r22,lo8(56)
 1280               	.L154:
 1281               		out 44-32,r22
 1282               		rjmp .L153
 1283               	.L80:
 1284               	.LBE233:
 1285               	.LBE232:
 1287               	.LM156:
 1288               		cpi r25,lo8(115)
 1289               		brne .L83
 1290               	.L106:
 1291               	.LBB234:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:2      *ABS*:0000003f __SREG__
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:3      *ABS*:0000003e __SP_H__
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:4      *ABS*:0000003d __SP_L__
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:5      *ABS*:00000034 __CCP__
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:6      *ABS*:00000000 __tmp_reg__
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:7      *ABS*:00000001 __zero_reg__
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:96     .text:00000000 __vector_default
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:110    .text:00000002 send_boot
C:\DOCUME~1\Admin\LOCALS~1\Temp/ccNib6Gc.s:216    .text:0000003c main
                            *COM*:00000080 gBuffer

UNDEFINED SYMBOLS
__eewr_byte_m16
__eerd_byte_m16
__do_clear_bss
